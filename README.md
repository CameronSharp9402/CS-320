# CS-320 Software Test/Automation QA

## How can I ensure that my code, program, or software is functional and secure?
I strongly back the functionality and security of my code, programs, and software through a solid base of <strong>unit testing, validation, and code reviews</strong>. Working on the Contact Service, Task Service, and Appointment Service projects has been instrumental in me taking up the practice of testing each method individually with <strong>JUnit</strong> so as to check that all expected behaviors were achieved and that invalid inputs were handled appropriately. Null values or incorrect field lengths, for instance, are the cases in which I made sure through the tests that exceptions would be triggered rather than the failure occurring silently. Besides testing, I am committed to <strong>secure coding practices</strong> like validating user input, limiting data exposure, and not hard, coding credentials. Such a way of thinking is my guarantee that the applications I write will be dependable and of good quality even when they are scaled or become part of a larger system. By keeping test coverage and continuous verification, I am able to be sure that the software is not only functioning as expected but also that it is safeguarded against the common security vulnerabilities.

## How do I interpret user needs and incorporate them into a program?
Understanding and incorporating user needs is a process that starts with <strong>careful analysis of requirements</strong> and changing them into unambiguous technical objectives. As an example, in the Contact Service milestone, the condition that contact IDs have to be unique and immutable was the factor that influenced both my data structure selections and validation logic. I was taught not to take user requirements at face value, but instead to find the <strong>reason</strong> behind those needs, which enables me to create functionalities that are adaptable, manageable and user, friendly. To be true to users' needs is also to produce good quality, understandable code that developers in the future will not find it difficult to grasp and extend. I keep checking my execution against the user's demands so that I am confident in delivering not only the required functions but also the right user experience.

## How do I approach designing software?
In software design, I mainly use a <strong>modular and test, driven</strong> approach. First, I map the core objects and their relationships, for example, Contact, Task, and Appointment, and then I create services around them that independently manage data operations. This practice brings about <strong>encapsulation</strong>, code reuse, and the process of locating errors becomes faster. Besides, I plan to scale my design such that my current in, memory structures can be easily changed to a database, backed system later on. Test driven development helps me to focus on writing code that achieves specific, measurable results. Ultimately, I see software design as a trade off between <strong>meeting requirements, maintaining flexibility, and ensuring quality</strong> through rigorous testing and continuous revisions.
